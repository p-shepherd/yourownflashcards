    {/* <View>
      <View>
        <Animated.View style={[styles.front, rStyle]}>
        <TextInput  ref={textInputRef} onFocus={handleFocus} placeholder="Enter front flashcard's text" style={styles.inputCategory}  value={flashcardFront}
              onChangeText={(text) => setFlashcardFront(text)}/>
        </Animated.View>
        <Animated.View style={[styles.back, bStyle]}>
          <Text>Back</Text>
        </Animated.View>
      </View>
      
    </View>
    
    
    
      </View>
      <TouchableOpacity
        onPress={() => (spin.value = spin.value ? 0 : 1)}
        style={{ marginTop: 30, alignItems: "center" }}
      >
        <Text style={styles.text3}>Flip</Text>
      </TouchableOpacity> */}

       const updateFlashcard = async (answeredRight, selectedBrackets) => {
      try {
        const userRef = doc(firestore, 'users', uid);
        const userDoc = await getDoc(userRef);
        if (userDoc.exists()) {
          const lastClicked = userDoc.data().lastClickedSubcategory;
          const userData = userDoc.data().data;
    
          for (const category of userData) {
            for (const subcategory of category.subcategories) {
              const subcategoryName = subcategory[Object.keys(subcategory)[0]].subcategoryName;
              if (subcategoryName.includes(lastClicked)) {
                const flashcardsHolder = subcategory[Object.keys(subcategory)[0]].flashcardsHolder || [];
    
                flashcardsHolder = flashcardsHolder.filter((flashcard) => selectedBrackets.includes(flashcard.bracket));
                const untrainedFlashcard = flashcardsHolder.find(flashcard => !flashcard.trained);
                if (untrainedFlashcard && answeredRight) {
                  untrainedFlashcard.trained = true; 
                  if (answeredRight && untrainedFlashcard.bracket <= 5) {
                    untrainedFlashcard.bracket++;
                  } else if (!answeredRight && untrainedFlashcard.bracket > 1) {
                    untrainedFlashcard.bracket--;
                  }
    
                  await updateDoc(userRef, {
                    data: userData
                  });
    
                  setTimeout(async () => {
                    const allFlashcardsTrained = flashcardsHolder.every(flashcard => flashcard.trained);
                    if (allFlashcardsTrained) {
                      flashcardsHolder.forEach(flashcard => {
                        flashcard.trained = false;
                      });
    
                      await updateDoc(userRef, {
                        data: userData
                      });
                      alert('All flashcards have been trained with! Restarting the session...');
                      setFlashcardFront('');
                      setFlashcardBack('');
                      fetchData();
                      modalVisible(true);
                      return;
                    }
                  }, 2000);
                  const selectedBrackets = Object.entries(checkboxes)
        .filter(([_, value]) => value)
        .map(([key]) => Number(key));
                  setFlashcardBack('');
                  setFlashcardFront('');
                  fetchFlashcardsByBrackets(selectedBrackets);
                  return; // Exit loop if the flashcard is updated
                }
              }
            }
          }
        }
      } catch (error) {
        console.error('Error updating flashcard:', error);
      }
    };
  

  {
                    backgroundColor: tinycolor(item.color).lighten(10).toHexString(),
                    color: getTextColorBasedOnBackground(tinycolor(item.color).lighten(20).toHexString()),
                  },

                          {/* <View>
      <View>
        <Animated.View style={[styles.front, rStyle]}>
        <TextInput  ref={textInputRef} onFocus={handleFocus} placeholder="Enter front flashcard's text" style={styles.inputCategory}  value={flashcardFront}
              onChangeText={(text) => setFlashcardFront(text)}/>
        </Animated.View>
        <Animated.View style={[styles.back, bStyle]}>
          <Text>Back</Text>
        </Animated.View>
      </View>
      
    </View>
    
    
    
      </View>
      <TouchableOpacity
        onPress={() => (spin.value = spin.value ? 0 : 1)}
        style={{ marginTop: 30, alignItems: "center" }}
      >
        <Text style={styles.text3}>Flip</Text>
      </TouchableOpacity> */}



      SESSION SCREEN

      import React, { useState, useEffect, useRef } from 'react';
import {Dimensions, Pressable,  View, Text, SafeAreaView, Platform, StatusBar, TextInput, TouchableOpacity, Image, Button, ScrollView, Modal, TouchableWithoutFeedback,} from 'react-native';
import { StyleSheet } from 'react-native';
import styles from './styles';
import { SelectList } from 'react-native-dropdown-select-list'
import {useNavigation} from '@react-navigation/core';
import { doc, getDoc, updateDoc, setDoc, collection, query, getDocs  } from "firebase/firestore";
import {auth, firestore} from './firebase';
import Animated, {
    Extrapolate,
    interpolate,
    useAnimatedStyle,
    useSharedValue,
    withSpring,
    withTiming,
  } from "react-native-reanimated";
  import GestureFlipView from 'react-native-gesture-flip-card';
  import { Svg, Path } from 'react-native-svg';
  import { deviceWidth, deviceHeight } from './styles';
  import Check from './assets/check-svgrepo-com.svg';

  import Box1 from './assets/1flashbox.svg';
  import Box2 from './assets/2flashbox.svg';
  import Box3 from './assets/3flashbox.svg';
  import Box4 from './assets/4flashbox.svg';
  import Box5 from './assets/5flashbox.svg';
  import Crown from './assets/crown.svg';
  import RainbowCrown from './assets/rainbow.svg';
  import Wrong from './assets/wrong.svg';
  import Right from './assets/right.svg';
import tinycolor from 'tinycolor2';
import BoxA from './assets/boxA.svg';
import BoxB from './assets/boxB.svg';
import BoxC from './assets/boxC.svg';
import BoxD from './assets/boxD.svg';
import BoxE from './assets/boxE.svg';
import BoxF from './assets/BoxF.svg';
import CrownA from './assets/crownA.svg';


StatusBar.setTranslucent(true);
StatusBar.setBackgroundColor('white');
const { height, width } = Dimensions.get('window');
const Session = () => {

    const [currentDate , setCurrentDate] = useState('?');
    const navigation = useNavigation();
    const [numberTotal, setNumberTotal] = useState(0);
    const [numberCurrent, setNumberCurrent] = useState(0);
    const [currentFlashcard, setCurrentFlashcard] = useState(0);
    const [boxOne, setBoxOne] = useState('black');
    const [boxTwo, setBoxTwo] = useState('black');
    const [boxThree, setBoxThree] = useState('black');
    const [boxFour, setBoxFour] = useState('black');
    const [boxFive, setBoxFive] = useState('black');
    const [boxCrown, setBoxCrown] = useState('black');
    const [checker, setChecker] = useState(false);
    const [showLastClicked, setShowLastClicked] = useState('');
   const[colorTheme , setColorTheme] = useState('black')
   const [showRainbowCrown, setShowRainbowCrown] = useState(false);

    const [flashcardType, setFlashcardType] = useState('?');

   const [boxAOpacity, setBoxAOpacity] = useState('0.2');
    const [boxBOpacity, setBoxBOpacity] = useState('0.2');
    const [boxCOpacity, setBoxCOpacity] = useState('0.2');
    const [boxDOpacity, setBoxDOpacity] = useState('0.2');
    const [boxEOpacity, setBoxEOpacity] = useState('0.2');
    const [boxFOpacity, setBoxFOpacity] = useState('0.2');
    const [AColor, setAColor] = useState('black');
    const [BColor, setBColor] = useState('black');
    const [CColor, setCColor] = useState('black');
    const [DColor, setDColor] = useState('black');
    const [EColor, setEColor] = useState('black');
    const [FColor, setFColor] = useState('black');
    const [currentBracket, setCurrentBracket] = useState(0);

   
    const spin = useSharedValue(0);

    const rStyle = useAnimatedStyle(() => {
      const spinVal = interpolate(spin.value, [0, 1], [0, -180]);
      return {
        transform: [
          {
            rotateY: withTiming(`${spinVal}deg`, { duration: 500 }),
          },
        ],
      };
    }, []);
  
    const bStyle = useAnimatedStyle(() => {
      const spinVal = interpolate(spin.value, [0, 1], [-180, -360]);
      return {
        transform: [
          {
            rotateY: withTiming(`${spinVal}deg`, { duration: 500 }),
          },
        ],
      };
    }, []);
  
    
  
   const [selected, setSelected] = useState('');
  
   const [flashcardFront, setFlashcardFront] = useState('');
   const [flashcardBack, setFlashcardBack] = useState('');
  
   const uid = auth.currentUser.uid;
   const [paths, setPaths] = useState([]);
 const [currentPath, setCurrentPath] = useState([]);
 

 const [paths2, setPaths2] = useState([]);
 const [currentPath2, setCurrentPath2] = useState([]);

   const [data, setData] = useState([]);
   const [isClearButtonClicked, setClearButtonClicked] = useState(false);
   const renderFront = () => {
    // Check if the flashcardFront contains more than three commas
    if (flashcardFront.split(',').length > 4) {
     
      // Return the Svg component
      return (
        <View style={{backgroundColor: 'white',
        width: deviceWidth * 0.90,
        height: deviceHeight * 0.35,
        alignContent: 'center',
        alignItems: 'center',
        justifyContent: 'center',
        borderRadius: 10,
        borderWidth: 2,
        borderColor: colorTheme}}>
        <Svg viewBox={`0 0 ${deviceWidth * 0.90} ${deviceHeight * 0.35}`}>
          <Path
            d={flashcardFront}
            stroke={isClearButtonClicked ? 'transparent' : 'black'}
            fill={'transparent'}
            strokeWidth={3}
            strokeLinejoin={'round'}
            strokeLinecap={'round'}
          />
          {paths.length > 0 &&
            paths.map((item, index) => (
              <Path
                key={`path-${index}`}
                d={item}
                stroke={isClearButtonClicked ? 'transparent' : 'black'}
                fill={'transparent'}
                strokeWidth={2}
                strokeLinejoin={'round'}
                strokeLinecap={'round'}
              />
            ))}
        </Svg>
        </View>
      );
    } else {
     
      return (
        <View style={{backgroundColor: 'white',
        width: deviceWidth * 0.90,
        height: deviceHeight * 0.35,
        alignContent: 'center',
        alignItems: 'center',
        justifyContent: 'center',
        borderRadius: 10,
        borderWidth: 2,
        borderColor: colorTheme}}>
          <Text style={styles.flashcardText}>{flashcardFront}</Text>
        </View>
      );
    }
  };
    
   

    const renderBack = () => {
      // Check if the flashcardFront contains more than three commas
      if (flashcardBack.split(',').length > 4) {
        // Return the Svg component
        return (
          <View style={{backgroundColor: 'white',
          width: deviceWidth * 0.90,
          height: deviceHeight * 0.35,
          alignContent: 'center',
          alignItems: 'center',
          justifyContent: 'center',
          borderRadius: 10,
          borderWidth: 2,
          borderColor: colorTheme}}>
          <Svg viewBox={`0 0 ${deviceWidth * 0.90} ${deviceHeight * 0.35}`}>
            <Path
              d={flashcardBack}
              stroke={isClearButtonClicked ? 'transparent' : 'black'}
              fill={'transparent'}
              strokeWidth={3}
              strokeLinejoin={'round'}
              strokeLinecap={'round'}
            />
            {paths2.length > 0 &&
              paths2.map((item, index) => (
                <Path
                  key={`path-${index}`}
                  d={item}
                  stroke={isClearButtonClicked ? 'transparent' : 'black'}
                  fill={'transparent'}
                  strokeWidth={2}
                  strokeLinejoin={'round'}
                  strokeLinecap={'round'}
                />
              ))}
          </Svg>
          </View>
        );
      } else {
        // Return the View with Text component
        return (
          <View style={{backgroundColor: 'white',
          width: deviceWidth * 0.90,
          height: deviceHeight * 0.35,
          alignContent: 'center',
          alignItems: 'center',
          justifyContent: 'center',
          borderRadius: 10,
          borderWidth: 2,
          borderColor: colorTheme}}>
            <Text style={styles.flashcardText}>{flashcardBack}</Text>
          </View>
        );
      }
    };
   
  
 
    const backHome = () => {
    navigation.navigate("MainScreen")
    }

    const [flashcardsCounts, setFlashcardsCounts] = useState({ 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6 : 0 });

    const countFlashcards = (flashcardsHolder) => {
      const counts = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6 : 0 };
    
      flashcardsHolder.forEach((flashcard) => {
        if (flashcard.bracket >= 1 && flashcard.bracket <= 6) {
          counts[flashcard.bracket]++;
        }
      });
    
      return counts;
    };

// wylapuje dobre ilosci flashcardow
    const fetchData = async () => {
      try {
        const userRef = doc(firestore, 'users', uid);
        const userDoc = await getDoc(userRef);
        if (userDoc.exists()) {
          const lastClicked = userDoc.data().lastClickedSubcategory;
          const userData = userDoc.data().data;
          setShowLastClicked(lastClicked);
    
          let counts = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6 : 0 };
    
          for (const category of userData) {
            for (const subcategory of category.subcategories) {
              const subcategoryName = subcategory[Object.keys(subcategory)[0]].subcategoryName;
              if (subcategoryName.includes(lastClicked)) {
                const flashcardsHolder = subcategory[Object.keys(subcategory)[0]].flashcardsHolder || [];

                
                counts = countFlashcards(flashcardsHolder);
    
                setFlashcardsCounts(counts); 
                if (flashcardsHolder.length < 1) {
                console.log(flashcardsHolder.length + "flashcardsHolder.length")
                setModalNo(true)
                setModalVisible(false)
              }
              let kolorek = category.color
              setColorTheme(tinycolor(kolorek).darken(10).saturate(20).toString(0))
              }
            }
            
          }
        }
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    };
    
        
//zapodaje dobre flashcardy
    const fetchFlashcardsByBrackets = async (selectedBrackets) => {
      
      const userRef = doc(firestore, 'users', uid);
      const userDoc = await getDoc(userRef);
      if (userDoc.exists()) {
        const lastClicked = userDoc.data().lastClickedSubcategory;
        const userData = userDoc.data().data;
        
        for (const category of userData) {
            for (const subcategory of category.subcategories) {
              const subcategoryName = subcategory[Object.keys(subcategory)[0]].subcategoryName;
              if (subcategoryName.includes(lastClicked)) {
              
              let flashcardsHolder = subcategory[Object.keys(subcategory)[0]].flashcardsHolder || [];
             
    
              flashcardsHolder = flashcardsHolder.filter((flashcard) => selectedBrackets.includes(flashcard.bracket));
              if (numberTotal == 0) {
                setNumberTotal(flashcardsHolder.length);
              }
              console.log(flashcardsHolder.length + "flashcardsHolder.length")
              console.log(flashcardsHolder + "flashcardsHolder")
             
              if (flashcardsHolder.length > 0) {
                
                const untrainedFlashcard = flashcardsHolder.find((flashcard) => !flashcard.trained);
                if (untrainedFlashcard) {
                  console.log(untrainedFlashcard.bracket + " bracket")
                  setCurrentFlashcard(untrainedFlashcard.bracket);
                  setFlashcardFront(untrainedFlashcard.frontContent);
                  setCurrentBracket(untrainedFlashcard.bracket);
                  setCurrentDate(untrainedFlashcard.creationDate);
                  setFlashcardBack(untrainedFlashcard.backContent);
                }
              }
            }
          }
        }
      }
    };

    const updateFlashcard = async (answeredRight, selectedBrackets) => {
      
      try {
        const userRef = doc(firestore, 'users', uid);
        const userDoc = await getDoc(userRef);
        if (userDoc.exists()) {
          const lastClicked = userDoc.data().lastClickedSubcategory;
          const userData = userDoc.data().data;
    
          for (const category of userData) {
            for (const subcategory of category.subcategories) {
              const subcategoryName = subcategory[Object.keys(subcategory)[0]].subcategoryName;
              if (subcategoryName.includes(lastClicked)) {
                let flashcardsHolder = subcategory[Object.keys(subcategory)[0]].flashcardsHolder || [];
    
                flashcardsHolder = flashcardsHolder.filter((flashcard) => selectedBrackets.includes(flashcard.bracket));
                

                setTimeout(async () => {
                  const allFlashcardsTrained = flashcardsHolder.every(flashcard => flashcard.trained);
                  if (allFlashcardsTrained) {
                    userData.forEach(category => {
                      category.subcategories.forEach(subcategory => {
                        const subcategoryKey = Object.keys(subcategory)[0];
                        const flashcardsHolder = subcategory[subcategoryKey].flashcardsHolder || [];
                        flashcardsHolder.forEach(flashcard => {
                          flashcard.trained = false;
                        });
                      });
                    });
            
                    // Update the document once after all changes
                    await updateDoc(userRef, {
                      data: userData
                    });
                    setNumberCurrent(0);
                    setNumberTotal(0);
                    alert('All flashcards have been trained with! Restarting the session...');
                    setCheckboxes(checkboxesAfter)
                    setFlashcardFront('');
                    setFlashcardBack('');
                    fetchData();
                    setModalVisible(true);
                    return;
                  }
                }, 500);
                const untrainedFlashcard = flashcardsHolder.find(flashcard => !flashcard.trained);
                if (untrainedFlashcard) {
                  untrainedFlashcard.trained = true;
                  if (answeredRight && untrainedFlashcard.bracket <= 6) {
                    setNumberCurrent(numberCurrent + 1);
                    if (currentFlashcard == 1) {
                      console.log("answered right")
                      setBoxTwo('green')
                      untrainedFlashcard.bracket++;
                      setTimeout(() => {
                        setBoxTwo('black')
                      }, 1000);
                    }
                    if (currentFlashcard == 2) {
                      console.log("answered right")
                      setBoxThree('green')
                      untrainedFlashcard.bracket++;
                      setTimeout(() => {
                        setBoxThree('black')
                      }, 1000);
                    }
                    if (currentFlashcard == 3) {
                      console.log("answered right")
                      setBoxFour('green')
                      untrainedFlashcard.bracket++;
                      setTimeout(() => {
                        setBoxFour('black')
                      }, 1000);
                    }
                    if (currentFlashcard == 4) {
                      console.log("answered right")
                      setBoxFive('green')
                      untrainedFlashcard.bracket++;
                      setTimeout(() => {
                        setBoxFive('black')
                      }, 1000);
                    }
                    if (currentFlashcard == 5) {
                      console.log("answered right")
                      setShowRainbowCrown(true)
                      setBoxCrown('green')
                      untrainedFlashcard.bracket++;
                      setTimeout(() => {
                        setShowRainbowCrown(false)
                        setBoxCrown('black')
                      }, 1000);
                    }
                    if (currentFlashcard == 6) {
                      
                      console.log("answered right")
                      setBoxCrown('green')
                      setTimeout(() => {
                        setBoxCrown('black')
                      }, 1000);
                    }
                    
                    
                  } else if (!answeredRight && untrainedFlashcard.bracket > 1) {
                    setNumberCurrent(numberCurrent + 1);
                    if (currentFlashcard == 2) {
                      console.log("answered wrong")
                      setBoxOne('red')
                      //wait for 1 second and set it back to black
                      setTimeout(() => {
                        setBoxOne('black')
                      }, 1000);
                    }
                    
                    if (currentFlashcard == 3) {
                      console.log("answered right")
                      setBoxTwo('red')
                      setTimeout(() => {
                        setBoxTwo('black')
                      }, 1000);
                    }
                    if (currentFlashcard == 4) {
                      console.log("answered right")
                      setBoxThree('red')
                      setTimeout(() => {
                        setBoxThree('black')
                      }, 1000);
                    }
                    if (currentFlashcard == 5) {
                      console.log("answered right")
                      setBoxFour('red')
                      setTimeout(() => {
                        setBoxFour('black')
                      }, 1000);
                    }
                    untrainedFlashcard.bracket--;
                    
                  }
                  else if (!answeredRight && untrainedFlashcard.bracket == 1) {
                    setNumberCurrent(numberCurrent + 1);
                    if (currentFlashcard == 1) {
                      console.log("answered wrong")
                      setBoxOne('red')
                      //wait for 1 second and set it back to black
                      setTimeout(() => {
                        setBoxOne('black')
                      }, 1000);
                    }
                    
                   
                  }
    
                  await updateDoc(userRef, {
                    data: userData
                  });
    
                  
                  const selectedBrackets = Object.entries(checkboxes)
                    .filter(([_, value]) => value)
                    .map(([key]) => Number(key));
                  setFlashcardBack('');
                  setFlashcardFront('');
                  fetchFlashcardsByBrackets(selectedBrackets);
                  
                  return; // Exit loop if the flashcard is updated
                }
              }
            }
          }
        }
      } catch (error) {
        console.error('Error updating flashcard:', error);
      }
    };

  
    
    useEffect(() => {
      
      fetchData();

      if (flashcardBack.split(',').length > 4) {
        setFlashcardType('drawn');
      } else {
        setFlashcardType('text');
      }
    }, [flashcardBack]); // Empty dependency array to run only on component mou
  const statusBarHeight = Platform.OS === 'android' ? StatusBar.currentHeight : 0;

  
    const [modalVisible, setModalVisible] = useState(true);
    const [modalNo, setModalNo] = useState(false);

    const [checkboxes, setCheckboxes] = useState({
      1: false,
      2: false,
      3: false,
      4: false,
      5: false,
      6: false,
      
    });
    const [checkboxesAfter, setCheckboxesAfter] = useState({
      1: false,
      2: false,
      3: false,
      4: false,
      5: false,
      6: false,
    });
    

    console.log(checkboxes)
    const handleCheckboxChange = (checkbox) => {
      const updatedCheckboxes = { ...checkboxes, [checkbox]: !checkboxes[checkbox] };
      setCheckboxes(updatedCheckboxes);

      if (checkbox === '1') {
        setAColor(updatedCheckboxes[checkbox] ? colorTheme : 'black');
        setBoxAOpacity(updatedCheckboxes[checkbox] ? '1' : '0.2')
      }

      if (checkbox === '2') {
        setBColor(updatedCheckboxes[checkbox] ? colorTheme : 'black');
        setBoxBOpacity(updatedCheckboxes[checkbox] ? '1' : '0.2')
      }

      if (checkbox === '3') {
        setCColor(updatedCheckboxes[checkbox] ? colorTheme : 'black');
        setBoxCOpacity(updatedCheckboxes[checkbox] ? '1' : '0.2')
      }

      if (checkbox === '4') {
        setDColor(updatedCheckboxes[checkbox] ? colorTheme : 'black');
        setBoxDOpacity(updatedCheckboxes[checkbox] ? '1' : '0.2')
      }

      if (checkbox === '5') {
        setEColor(updatedCheckboxes[checkbox] ? colorTheme : 'black');
        setBoxEOpacity(updatedCheckboxes[checkbox] ? '1' : '0.2')

      }

      if (checkbox === '6') {
        setFColor(updatedCheckboxes[checkbox] ? colorTheme : 'black');
        setBoxFOpacity(updatedCheckboxes[checkbox] ? '1' : '0.2')

      }
    };
  
    const startSession = () => {
      setAColor('black');
      setBColor('black');
      setCColor('black');
      setDColor('black');
      setEColor('black');
      setBoxAOpacity('0.2');
      setBoxBOpacity('0.2');
      setBoxCOpacity('0.2');
      setBoxDOpacity('0.2');
      setBoxEOpacity('0.2');
      const selectedBrackets = Object.entries(checkboxes)
        .filter(([_, value]) => value)
        .map(([key]) => Number(key));
        console.log(selectedBrackets)
        
      if (selectedBrackets.length > 0) {
        setModalVisible(false);
        fetchFlashcardsByBrackets(selectedBrackets); // Fetch flashcards for the session based on selected brackets
      } else {
        // Alert or handle if no checkbox is selected
      }};
    
      const selectedBrackets = Object.entries(checkboxes)
        .filter(([_, value]) => value)
        .map(([key]) => Number(key));

        const setBracketsToOne = async () => {
          const userRef = doc(firestore, 'users', uid);
          try {
            const userDoc = await getDoc(userRef);
            if (userDoc.exists()) {
              const userData = userDoc.data().data;
        
              // Iterate through each category and subcategory to find and reset flashcards
              userData.forEach(category => {
                category.subcategories.forEach(subcategory => {
                  const flashcardsHolder = subcategory[Object.keys(subcategory)[0]].flashcardsHolder || [];
                  flashcardsHolder.forEach(flashcard => {
                    if (flashcard.bracket === 6) {
                      flashcard.bracket = 1; // Reset bracket to 1
                    }
                  });
                });
              });
        
              // Update the Firestore document
              await updateDoc(userRef, {
                data: userData
              });
              setNumberCurrent(0);
              setNumberTotal(0);
              
              setCheckboxes(checkboxesAfter)
              setFlashcardFront('');
              setFlashcardBack('');
              fetchData();
              setModalVisible(true);
              alert('All learned flashcards have been reset.');
              // Optionally, you can re-fetch or update local state here if necessary
            }
          } catch (error) {
            console.error('Error updating flashcards:', error);
          }
        };
  return (
    <SafeAreaView style={[styles.container, { marginTop: statusBarHeight }]}>
      <View style={styles.loginContainer2}>
        <TouchableOpacity onPress={backHome} style={styles.backToMain}>
          <Text style={{ textAlign: 'left', fontSize: 20, padding: 10, paddingTop: 5 }}>
            <Image source={require('./assets/arrow_left.png')} style={styles.iconStyle3} />
            Back to MainScreen
          </Text>
        </TouchableOpacity>
        <Text style={{marginBottom: 20,marginTop:10, color: colorTheme, fontSize: 25, fontWeight: 500,}}>{showLastClicked}</Text>
        
        <GestureFlipView width={deviceWidth * 0.90} height={deviceHeight * 0.35}>
          {renderBack()}
          {renderFront()}
        </GestureFlipView>
        <View style={{flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'space-around', }}>
        
        <TouchableOpacity onPress={() => updateFlashcard(false, selectedBrackets)} style={{ marginTop: 20, marginRight: 40}}>
          <Wrong width="70" height="70"/>
        </TouchableOpacity>

        <TouchableOpacity onPress={() => updateFlashcard(true, selectedBrackets)} style={{ marginTop: 20, marginLeft: 40 }}>
          <Right width="70" height="70"/>
        </TouchableOpacity>
        
        </View>
        <View style={{justifyContent: 'center', alignItems: 'center'   }}>
          <Text style={{fontSize: 24, fontWeight: 400, marginTop: 15}}>Flashcard: {numberCurrent}/{numberTotal}</Text>
          <View style={{justifyContent: 'center', alignItes: 'center', marginTop: 30 }}>
                <Text style={{fontSize: 16}}>
                Flashcard box : {currentBracket}
                </Text>
                
                
          </View>
          <View style={{justifyContent: 'center', alignItems: 'center' ,marginTop: 30  }}>
            
               <TouchableOpacity style={{backgroundColor: '#c0c0c0', width: deviceWidth * 0.70, height: deviceHeight*0.05
              , justifyContent: 'center', alignItems: 'center', borderRadius: 10, opacity: 1}}>

                <Text style={styles.clearButtonTextL} onPress={setBracketsToOne}>Reset Learned Flashcards</Text>

                </TouchableOpacity>
                
          </View>
        </View>
       
      </View>
      <View style={{ flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'space-around', marginBottom: 20, padding: 0, margin: 0}}>
              <Box1 width="50" height="50" fill="none" stroke={boxOne} />
              <Box2 width="50" height="50" fill="none" stroke={boxTwo} />
              <Box3 width="50" height="50" fill="none" stroke={boxThree}/>
              <Box4 width="50" height="50" fill="none" stroke={boxFour} />
              <Box5 width="50" height="50" fill="none" stroke={boxFive} />
              {/* {showRainbowCrown ? 
        <RainbowCrown width="50" height="50" /> :  */}
        <Crown width="50" height="50" fill="none" stroke={boxCrown} />
      {/* } */}

            </View>
      <Modal
  animationType="fade"
  transparent={true}
  visible={modalNo}
  onRequestClose={() => setModalNo(false)}
>
  <TouchableWithoutFeedback>
    <View style={styles.modalOverlay}>
      <View style={styles.modalContent}>
        {/* Close Button */}
        <TouchableOpacity 
          style={styles.closeButton} 
          onPress={() => backHome()}
        >
          <Text style={styles.closeButtonText}>X</Text>
        </TouchableOpacity>

        <Text>There are no flashcards to learn with inside this subcategory... 
          Come back after creating some flashcards!</Text>
      </View>
    </View>
  </TouchableWithoutFeedback>
</Modal>

      <Modal
        animationType="fade"
        transparent={true}
        visible={modalVisible}
        onRequestClose={() => setModalVisible(false)}
      >
        <TouchableWithoutFeedback>
          <View style={styles.modalOverlay}>
        
    {/* Add more SVGs as needed */}
  
            <View style={styles.modalContent}>
            <View style={{position: 'absolute', top: 10, zIndex: 1, left: 10}}>
    <BoxA width="100" height="100" stroke={AColor}  fill="none" opacity={boxAOpacity} />
    </View>
    <View style={{position: 'absolute', top: 30, zIndex: 1, right: 5}}>
    <BoxB width="110" height="110" stroke={BColor}  fill="none"  opacity={boxBOpacity}/>
    </View>
    <View style={{position: 'absolute', top: 305, zIndex: 1, left: 25}}>
    <BoxC width="100" height="100" stroke={CColor}  fill="none"  opacity={boxCOpacity}/>
    </View>
    <View style={{position: 'absolute', top: 180, zIndex: 1, right: 10}}>
    <BoxD width="90" height="90" stroke={DColor}  fill="none"  opacity={boxDOpacity}/>
    </View>
    <View style={{position: 'absolute', top: 170, zIndex: 1, left: 10}}>
    <BoxE width="80" height="80" stroke={EColor}  fill="none"  opacity={boxEOpacity}/>
    </View>
    <View style={{position: 'absolute', top: 310, zIndex: 1, right: 25}}>
    <CrownA width="100" height="100" stroke={FColor}  fill="none"  opacity={boxFOpacity}/>
    </View>
              {
                Object.keys(checkboxes).map((checkbox) => (
                  <TouchableOpacity
                    key={checkbox}
                    style={[
                      styles.checkboxContainer,
                      flashcardsCounts[checkbox] < 1 && { opacity: 0.35, zIndex: 2 },
                    ]}
                    onPress={() => handleCheckboxChange(checkbox)}
                    disabled={flashcardsCounts[checkbox] < 1}
                  >
                    <Text>{checkbox}</Text>
                    <View
                      style={[
                        styles.checkbox,
                        { backgroundColor: checkboxes[checkbox] ? '#100c08' : 'white', zIndex: 2  },
                      ]}
                    /><View style={{position:'absolute',zIndex: 5, left: 15}}><Check width="35" height="35"/></View>
                    <Text>({flashcardsCounts[checkbox]})</Text>
                  </TouchableOpacity>
                ))
              }
              <TouchableOpacity
                style={[
                  styles.startButton,
                  {
                    opacity: Object.values(checkboxes).some((value) => value) ? 1 : 0.5,
                    marginTop: 10,
                    marginBottom: 10,
        padding: 10,
        backgroundColor: '#100c08',
        borderRadius: 5,
        zIndex: 2,
                  },
                ]}
                disabled={!Object.values(checkboxes).some((value) => value)}
                onPress={startSession}
              >
                <Text style={styles.startButtonText}>Start Session</Text>
              </TouchableOpacity>
              <TouchableOpacity 
          style={styles.closeButton} 
          onPress={() => backHome()}
        >
          <Text style={styles.closeButtonText}>X</Text>
        </TouchableOpacity>
            </View>
            
          </View>
        </TouchableWithoutFeedback>
      </Modal>
      
    </SafeAreaView>
  );
              }

export default Session;


 const updateFlashcardOld = async (answeredRight, selectedBrackets) => {
      
      try {
        const userRef = doc(firestore, 'users', uid);
        const userDoc = await getDoc(userRef);
        if (userDoc.exists()) {
          const lastClicked = userDoc.data().lastClickedSubcategory;
          const userData = userDoc.data().data;
    
          for (const category of userData) {
            for (const subcategory of category.subcategories) {
              const subcategoryName = subcategory[Object.keys(subcategory)[0]].subcategoryName;
              if (subcategoryName.includes(lastClicked)) {
                let flashcardsHolder = subcategory[Object.keys(subcategory)[0]].flashcardsHolder || [];
    
                flashcardsHolder = flashcardsHolder.filter((flashcard) => selectedBrackets.includes(flashcard.bracket));
                

                setTimeout(async () => {
                  const allFlashcardsTrained = flashcardsHolder.every(flashcard => flashcard.trained);
                  if (allFlashcardsTrained) {
                    userData.forEach(category => {
                      category.subcategories.forEach(subcategory => {
                        const subcategoryKey = Object.keys(subcategory)[0];
                        const flashcardsHolder = subcategory[subcategoryKey].flashcardsHolder || [];
                        flashcardsHolder.forEach(flashcard => {
                          flashcard.trained = false;
                        });
                      });
                    });
            
                    // Update the document once after all changes
                    await updateDoc(userRef, {
                      data: userData
                    });
                    setNumberCurrent(0);
                    setNumberTotal(0);
                    alert('All flashcards have been trained with! Restarting the session...');
                    setCheckboxes(checkboxesAfter)
                    setFlashcardFront('');
                    setFlashcardBack('');
                    fetchData();
                    setModalVisible(true);
                    return;
                  }
                }, 500);
                const untrainedFlashcard = flashcardsHolder.find(flashcard => !flashcard.trained);
                if (untrainedFlashcard) {
                  untrainedFlashcard.trained = true;
                  if (answeredRight && untrainedFlashcard.bracket <= 6) {
                    setNumberCurrent(numberCurrent + 1);
                    if (currentFlashcard == 1) {
                      console.log("answered right")
                      setBoxTwo('green')
                      untrainedFlashcard.bracket++;
                      setTimeout(() => {
                        setBoxTwo('black')
                      }, 1000);
                    }
                    if (currentFlashcard == 2) {
                      console.log("answered right")
                      setBoxThree('green')
                      untrainedFlashcard.bracket++;
                      setTimeout(() => {
                        setBoxThree('black')
                      }, 1000);
                    }
                    if (currentFlashcard == 3) {
                      console.log("answered right")
                      setBoxFour('green')
                      untrainedFlashcard.bracket++;
                      setTimeout(() => {
                        setBoxFour('black')
                      }, 1000);
                    }
                    if (currentFlashcard == 4) {
                      console.log("answered right")
                      setBoxFive('green')
                      untrainedFlashcard.bracket++;
                      setTimeout(() => {
                        setBoxFive('black')
                      }, 1000);
                    }
                    if (currentFlashcard == 5) {
                      console.log("answered right")
                      setShowRainbowCrown(true)
                      setBoxCrown('green')
                      untrainedFlashcard.bracket++;
                      setTimeout(() => {
                        setShowRainbowCrown(false)
                        setBoxCrown('black')
                      }, 1000);
                    }
                    if (currentFlashcard == 6) {
                      
                      console.log("answered right")
                      setBoxCrown('green')
                      setTimeout(() => {
                        setBoxCrown('black')
                      }, 1000);
                    }
                    
                    
                  } else if (!answeredRight && untrainedFlashcard.bracket > 1) {
                    setNumberCurrent(numberCurrent + 1);
                    if (currentFlashcard == 2) {
                      console.log("answered wrong")
                      setBoxOne('red')
                      //wait for 1 second and set it back to black
                      setTimeout(() => {
                        setBoxOne('black')
                      }, 1000);
                    }
                    
                    if (currentFlashcard == 3) {
                      console.log("answered right")
                      setBoxTwo('red')
                      setTimeout(() => {
                        setBoxTwo('black')
                      }, 1000);
                    }
                    if (currentFlashcard == 4) {
                      console.log("answered right")
                      setBoxThree('red')
                      setTimeout(() => {
                        setBoxThree('black')
                      }, 1000);
                    }
                    if (currentFlashcard == 5) {
                      console.log("answered right")
                      setBoxFour('red')
                      setTimeout(() => {
                        setBoxFour('black')
                      }, 1000);
                    }
                    untrainedFlashcard.bracket--;
                    
                  }
                  else if (!answeredRight && untrainedFlashcard.bracket == 1) {
                    setNumberCurrent(numberCurrent + 1);
                    if (currentFlashcard == 1) {
                      console.log("answered wrong")
                      setBoxOne('red')
                      //wait for 1 second and set it back to black
                      setTimeout(() => {
                        setBoxOne('black')
                      }, 1000);
                    }
                    
                   
                  }
    
                  await updateDoc(userRef, {
                    data: userData
                  });
    
                  
                  const selectedBrackets = Object.entries(checkboxes)
                    .filter(([_, value]) => value)
                    .map(([key]) => Number(key));
                  setFlashcardBack('');
                  setFlashcardFront('');
                  fetchFlashcardsByBrackets(selectedBrackets);
                  
                  return; // Exit loop if the flashcard is updated
                }
              }
            }
          }
        }
      } catch (error) {
        console.error('Error updating flashcard:', error);
      }
    };

    // import React, { useState, useEffect, useRef } from 'react';
// import {Dimensions, Pressable,  View, Text, SafeAreaView, Platform, StatusBar, TextInput, TouchableOpacity, Image, Button, ScrollView, Modal, TouchableWithoutFeedback,} from 'react-native';
// import { StyleSheet } from 'react-native';
// import styles from './styles';
// import { SelectList } from 'react-native-dropdown-select-list'
// import {useNavigation} from '@react-navigation/core';
// import { doc, getDoc, updateDoc, setDoc, collection, query, getDocs  } from "firebase/firestore";
// import {auth, firestore} from './firebase';
// import Animated, {
//     Extrapolate,
//     interpolate,
//     useAnimatedStyle,
//     useSharedValue,
//     withSpring,
//     withTiming,
//   } from "react-native-reanimated";
//   import GestureFlipView from 'react-native-gesture-flip-card';
//   import { Svg, Path } from 'react-native-svg';
//   import { deviceWidth, deviceHeight } from './styles';
//   import Check from './assets/check-svgrepo-com.svg';

//   import Box1 from './assets/1flashbox.svg';
//   import Box2 from './assets/2flashbox.svg';
//   import Box3 from './assets/3flashbox.svg';
//   import Box4 from './assets/4flashbox.svg';
//   import Box5 from './assets/5flashbox.svg';
//   import Crown from './assets/crown.svg';
//   import RainbowCrown from './assets/rainbow.svg';
//   import Wrong from './assets/wrong.svg';
//   import Right from './assets/right.svg';
// import tinycolor from 'tinycolor2';
// import BoxA from './assets/boxA.svg';
// import BoxB from './assets/boxB.svg';
// import BoxC from './assets/boxC.svg';
// import BoxD from './assets/boxD.svg';
// import BoxE from './assets/boxE.svg';
// import BoxF from './assets/BoxF.svg';
// import CrownA from './assets/crownA.svg';


// StatusBar.setTranslucent(true);
// StatusBar.setBackgroundColor('white');
// const { height, width } = Dimensions.get('window');
// const Session = () => {

//     const [currentDate , setCurrentDate] = useState('?');
//     const navigation = useNavigation();
//     const [numberTotal, setNumberTotal] = useState(0);
//     const [numberCurrent, setNumberCurrent] = useState(0);
//     const [currentFlashcard, setCurrentFlashcard] = useState(0);
//     const [boxOne, setBoxOne] = useState('black');
//     const [boxTwo, setBoxTwo] = useState('black');
//     const [boxThree, setBoxThree] = useState('black');
//     const [boxFour, setBoxFour] = useState('black');
//     const [boxFive, setBoxFive] = useState('black');
//     const [boxCrown, setBoxCrown] = useState('black');
//     const [checker, setChecker] = useState(false);
//     const [showLastClicked, setShowLastClicked] = useState('');
//    const[colorTheme , setColorTheme] = useState('black')
//    const [showRainbowCrown, setShowRainbowCrown] = useState(false);

//     const [flashcardType, setFlashcardType] = useState('?');

//    const [boxAOpacity, setBoxAOpacity] = useState('0.2');
//     const [boxBOpacity, setBoxBOpacity] = useState('0.2');
//     const [boxCOpacity, setBoxCOpacity] = useState('0.2');
//     const [boxDOpacity, setBoxDOpacity] = useState('0.2');
//     const [boxEOpacity, setBoxEOpacity] = useState('0.2');
//     const [boxFOpacity, setBoxFOpacity] = useState('0.2');
//     const [AColor, setAColor] = useState('black');
//     const [BColor, setBColor] = useState('black');
//     const [CColor, setCColor] = useState('black');
//     const [DColor, setDColor] = useState('black');
//     const [EColor, setEColor] = useState('black');
//     const [FColor, setFColor] = useState('black');
//     const [currentBracket, setCurrentBracket] = useState(0);

   
//     const spin = useSharedValue(0);

//     const rStyle = useAnimatedStyle(() => {
//       const spinVal = interpolate(spin.value, [0, 1], [0, -180]);
//       return {
//         transform: [
//           {
//             rotateY: withTiming(`${spinVal}deg`, { duration: 500 }),
//           },
//         ],
//       };
//     }, []);
  
//     const bStyle = useAnimatedStyle(() => {
//       const spinVal = interpolate(spin.value, [0, 1], [-180, -360]);
//       return {
//         transform: [
//           {
//             rotateY: withTiming(`${spinVal}deg`, { duration: 500 }),
//           },
//         ],
//       };
//     }, []);
  
    
  
//    const [selected, setSelected] = useState('');
  
//    const [flashcardFront, setFlashcardFront] = useState('');
//    const [flashcardBack, setFlashcardBack] = useState('');
  
//    const uid = auth.currentUser.uid;
//    const [paths, setPaths] = useState([]);
//  const [currentPath, setCurrentPath] = useState([]);
 

//  const [paths2, setPaths2] = useState([]);
//  const [currentPath2, setCurrentPath2] = useState([]);

//    const [data, setData] = useState([]);
//    const [isClearButtonClicked, setClearButtonClicked] = useState(false);
//    const renderFront = () => {
//     // Check if the flashcardFront contains more than three commas
//     if (flashcardFront.split(',').length > 4) {
     
//       // Return the Svg component
//       return (
//         <View style={{backgroundColor: 'white',
//         width: deviceWidth * 0.90,
//         height: deviceHeight * 0.35,
//         alignContent: 'center',
//         alignItems: 'center',
//         justifyContent: 'center',
//         borderRadius: 10,
//         borderWidth: 2,
//         borderColor: colorTheme}}>
//         <Svg viewBox={`0 0 ${deviceWidth * 0.90} ${deviceHeight * 0.35}`}>
//           <Path
//             d={flashcardFront}
//             stroke={isClearButtonClicked ? 'transparent' : 'black'}
//             fill={'transparent'}
//             strokeWidth={3}
//             strokeLinejoin={'round'}
//             strokeLinecap={'round'}
//           />
//           {paths.length > 0 &&
//             paths.map((item, index) => (
//               <Path
//                 key={`path-${index}`}
//                 d={item}
//                 stroke={isClearButtonClicked ? 'transparent' : 'black'}
//                 fill={'transparent'}
//                 strokeWidth={2}
//                 strokeLinejoin={'round'}
//                 strokeLinecap={'round'}
//               />
//             ))}
//         </Svg>
//         </View>
//       );
//     } else {
     
//       return (
//         <View style={{backgroundColor: 'white',
//         width: deviceWidth * 0.90,
//         height: deviceHeight * 0.35,
//         alignContent: 'center',
//         alignItems: 'center',
//         justifyContent: 'center',
//         borderRadius: 10,
//         borderWidth: 2,
//         borderColor: colorTheme}}>
//           <Text style={styles.flashcardText}>{flashcardFront}</Text>
//         </View>
//       );
//     }
//   };
    
   

//     const renderBack = () => {
//       // Check if the flashcardFront contains more than three commas
//       if (flashcardBack.split(',').length > 4) {
//         // Return the Svg component
//         return (
//           <View style={{backgroundColor: 'white',
//           width: deviceWidth * 0.90,
//           height: deviceHeight * 0.35,
//           alignContent: 'center',
//           alignItems: 'center',
//           justifyContent: 'center',
//           borderRadius: 10,
//           borderWidth: 2,
//           borderColor: colorTheme}}>
//           <Svg viewBox={`0 0 ${deviceWidth * 0.90} ${deviceHeight * 0.35}`}>
//             <Path
//               d={flashcardBack}
//               stroke={isClearButtonClicked ? 'transparent' : 'black'}
//               fill={'transparent'}
//               strokeWidth={3}
//               strokeLinejoin={'round'}
//               strokeLinecap={'round'}
//             />
//             {paths2.length > 0 &&
//               paths2.map((item, index) => (
//                 <Path
//                   key={`path-${index}`}
//                   d={item}
//                   stroke={isClearButtonClicked ? 'transparent' : 'black'}
//                   fill={'transparent'}
//                   strokeWidth={2}
//                   strokeLinejoin={'round'}
//                   strokeLinecap={'round'}
//                 />
//               ))}
//           </Svg>
//           </View>
//         );
//       } else {
//         // Return the View with Text component
//         return (
//           <View style={{backgroundColor: 'white',
//           width: deviceWidth * 0.90,
//           height: deviceHeight * 0.35,
//           alignContent: 'center',
//           alignItems: 'center',
//           justifyContent: 'center',
//           borderRadius: 10,
//           borderWidth: 2,
//           borderColor: colorTheme}}>
//             <Text style={styles.flashcardText}>{flashcardBack}</Text>
//           </View>
//         );
//       }
//     };
   
  
 
//     const backHome = () => {
//     navigation.navigate("MainScreen")
//     }

//     const [flashcardsCounts, setFlashcardsCounts] = useState({ 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6 : 0 });

//     const countFlashcards = (flashcardsHolder) => {
//       const counts = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6 : 0 };
    
//       flashcardsHolder.forEach((flashcard) => {
//         if (flashcard.bracket >= 1 && flashcard.bracket <= 6) {
//           counts[flashcard.bracket]++;
//         }
//       });
    
//       return counts;
//     };

// // wylapuje dobre ilosci flashcardow
//     const fetchData = async () => {
//       try {
//         const userRef = doc(firestore, 'users', uid);
//         const userDoc = await getDoc(userRef);
//         if (userDoc.exists()) {
//           const lastClicked = userDoc.data().lastClickedSubcategory;
//           const userData = userDoc.data().data;
//           setShowLastClicked(lastClicked);
    
//           let counts = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6 : 0 };
    
//           for (const category of userData) {
//             for (const subcategory of category.subcategories) {
//               const subcategoryName = subcategory[Object.keys(subcategory)[0]].subcategoryName;
//               if (subcategoryName.includes(lastClicked)) {
//                 const flashcardsHolder = subcategory[Object.keys(subcategory)[0]].flashcardsHolder || [];

                
//                 counts = countFlashcards(flashcardsHolder);
    
//                 setFlashcardsCounts(counts); 
//                 if (flashcardsHolder.length < 1) {
//                 console.log(flashcardsHolder.length + "flashcardsHolder.length")
//                 setModalNo(true)
//                 setModalVisible(false)
//               }
//               let kolorek = category.color
//               setColorTheme(tinycolor(kolorek).darken(10).saturate(20).toString(0))
//               }
//             }
            
//           }
//         }
//       } catch (error) {
//         console.error('Error fetching data:', error);
//       }
//     };
    
        
// //zapodaje dobre flashcardy
//     const fetchFlashcardsByBrackets = async (selectedBrackets) => {
      
//       const userRef = doc(firestore, 'users', uid);
//       const userDoc = await getDoc(userRef);
//       if (userDoc.exists()) {
//         const lastClicked = userDoc.data().lastClickedSubcategory;
//         const userData = userDoc.data().data;
        
//         for (const category of userData) {
//             for (const subcategory of category.subcategories) {
//               const subcategoryName = subcategory[Object.keys(subcategory)[0]].subcategoryName;
//               if (subcategoryName.includes(lastClicked)) {
              
//               let flashcardsHolder = subcategory[Object.keys(subcategory)[0]].flashcardsHolder || [];
             
    
//               flashcardsHolder = flashcardsHolder.filter((flashcard) => selectedBrackets.includes(flashcard.bracket));
//               if (numberTotal == 0) {
//                 setNumberTotal(flashcardsHolder.length);
//               }
//               console.log(flashcardsHolder.length + "flashcardsHolder.length")
//               console.log(flashcardsHolder + "flashcardsHolder")
             
//               if (flashcardsHolder.length > 0) {
                
//                 const untrainedFlashcard = flashcardsHolder.find((flashcard) => !flashcard.trained);
//                 if (untrainedFlashcard) {
//                   console.log(untrainedFlashcard.bracket + " bracket")
//                   setCurrentFlashcard(untrainedFlashcard.bracket);
//                   setFlashcardFront(untrainedFlashcard.frontContent);
//                   setCurrentBracket(untrainedFlashcard.bracket);
//                   setCurrentDate(untrainedFlashcard.creationDate);
//                   setFlashcardBack(untrainedFlashcard.backContent);
//                 }
//               }
//             }
//           }
//         }
//       }
//     };

//     const updateFlashcard = async (answeredRight, selectedBrackets) => {
      
//       try {
//         const userRef = doc(firestore, 'users', uid);
//         const userDoc = await getDoc(userRef);
//         if (userDoc.exists()) {
//           const lastClicked = userDoc.data().lastClickedSubcategory;
//           const userData = userDoc.data().data;
    
//           for (const category of userData) {
//             for (const subcategory of category.subcategories) {
//               const subcategoryName = subcategory[Object.keys(subcategory)[0]].subcategoryName;
//               if (subcategoryName.includes(lastClicked)) {
//                 let flashcardsHolder = subcategory[Object.keys(subcategory)[0]].flashcardsHolder || [];
    
//                 flashcardsHolder = flashcardsHolder.filter((flashcard) => selectedBrackets.includes(flashcard.bracket));
                

//                 setTimeout(async () => {
//                   const allFlashcardsTrained = flashcardsHolder.every(flashcard => flashcard.trained);
//                   if (allFlashcardsTrained) {
//                     userData.forEach(category => {
//                       category.subcategories.forEach(subcategory => {
//                         const subcategoryKey = Object.keys(subcategory)[0];
//                         const flashcardsHolder = subcategory[subcategoryKey].flashcardsHolder || [];
//                         flashcardsHolder.forEach(flashcard => {
//                           flashcard.trained = false;
//                         });
//                       });
//                     });
            
//                     // Update the document once after all changes
//                     await updateDoc(userRef, {
//                       data: userData
//                     });
//                     setNumberCurrent(0);
//                     setNumberTotal(0);
//                     alert('All flashcards have been trained with! Restarting the session...');
//                     setCheckboxes(checkboxesAfter)
//                     setFlashcardFront('');
//                     setFlashcardBack('');
//                     fetchData();
//                     setModalVisible(true);
//                     return;
//                   }
//                 }, 500);
//                 const untrainedFlashcard = flashcardsHolder.find(flashcard => !flashcard.trained);
//                 if (untrainedFlashcard) {
//                   untrainedFlashcard.trained = true;
//                   if (answeredRight && untrainedFlashcard.bracket <= 6) {
//                     setNumberCurrent(numberCurrent + 1);
//                     if (currentFlashcard == 1) {
//                       console.log("answered right")
//                       setBoxTwo('green')
//                       untrainedFlashcard.bracket++;
//                       setTimeout(() => {
//                         setBoxTwo('black')
//                       }, 1000);
//                     }
//                     if (currentFlashcard == 2) {
//                       console.log("answered right")
//                       setBoxThree('green')
//                       untrainedFlashcard.bracket++;
//                       setTimeout(() => {
//                         setBoxThree('black')
//                       }, 1000);
//                     }
//                     if (currentFlashcard == 3) {
//                       console.log("answered right")
//                       setBoxFour('green')
//                       untrainedFlashcard.bracket++;
//                       setTimeout(() => {
//                         setBoxFour('black')
//                       }, 1000);
//                     }
//                     if (currentFlashcard == 4) {
//                       console.log("answered right")
//                       setBoxFive('green')
//                       untrainedFlashcard.bracket++;
//                       setTimeout(() => {
//                         setBoxFive('black')
//                       }, 1000);
//                     }
//                     if (currentFlashcard == 5) {
//                       console.log("answered right")
//                       setShowRainbowCrown(true)
//                       setBoxCrown('green')
//                       untrainedFlashcard.bracket++;
//                       setTimeout(() => {
//                         setShowRainbowCrown(false)
//                         setBoxCrown('black')
//                       }, 1000);
//                     }
//                     if (currentFlashcard == 6) {
                      
//                       console.log("answered right")
//                       setBoxCrown('green')
//                       setTimeout(() => {
//                         setBoxCrown('black')
//                       }, 1000);
//                     }
                    
                    
//                   } else if (!answeredRight && untrainedFlashcard.bracket > 1) {
//                     setNumberCurrent(numberCurrent + 1);
//                     if (currentFlashcard == 2) {
//                       console.log("answered wrong")
//                       setBoxOne('red')
//                       //wait for 1 second and set it back to black
//                       setTimeout(() => {
//                         setBoxOne('black')
//                       }, 1000);
//                     }
                    
//                     if (currentFlashcard == 3) {
//                       console.log("answered right")
//                       setBoxTwo('red')
//                       setTimeout(() => {
//                         setBoxTwo('black')
//                       }, 1000);
//                     }
//                     if (currentFlashcard == 4) {
//                       console.log("answered right")
//                       setBoxThree('red')
//                       setTimeout(() => {
//                         setBoxThree('black')
//                       }, 1000);
//                     }
//                     if (currentFlashcard == 5) {
//                       console.log("answered right")
//                       setBoxFour('red')
//                       setTimeout(() => {
//                         setBoxFour('black')
//                       }, 1000);
//                     }
//                     untrainedFlashcard.bracket--;
                    
//                   }
//                   else if (!answeredRight && untrainedFlashcard.bracket == 1) {
//                     setNumberCurrent(numberCurrent + 1);
//                     if (currentFlashcard == 1) {
//                       console.log("answered wrong")
//                       setBoxOne('red')
//                       //wait for 1 second and set it back to black
//                       setTimeout(() => {
//                         setBoxOne('black')
//                       }, 1000);
//                     }
                    
                   
//                   }
    
//                   await updateDoc(userRef, {
//                     data: userData
//                   });
    
                  
//                   const selectedBrackets = Object.entries(checkboxes)
//                     .filter(([_, value]) => value)
//                     .map(([key]) => Number(key));
//                   setFlashcardBack('');
//                   setFlashcardFront('');
//                   fetchFlashcardsByBrackets(selectedBrackets);
                  
//                   return; // Exit loop if the flashcard is updated
//                 }
//               }
//             }
//           }
//         }
//       } catch (error) {
//         console.error('Error updating flashcard:', error);
//       }
//     };

  
    
//     useEffect(() => {
      
//       fetchData();

//       if (flashcardBack.split(',').length > 4) {
//         setFlashcardType('drawn');
//       } else {
//         setFlashcardType('text');
//       }
//     }, [flashcardBack]); // Empty dependency array to run only on component mou
//   const statusBarHeight = Platform.OS === 'android' ? StatusBar.currentHeight : 0;

  
//     const [modalVisible, setModalVisible] = useState(true);
//     const [modalNo, setModalNo] = useState(false);

//     const [checkboxes, setCheckboxes] = useState({
//       1: false,
//       2: false,
//       3: false,
//       4: false,
//       5: false,
//       6: false,
      
//     });
//     const [checkboxesAfter, setCheckboxesAfter] = useState({
//       1: false,
//       2: false,
//       3: false,
//       4: false,
//       5: false,
//       6: false,
//     });
    

//     console.log(checkboxes)
//     const handleCheckboxChange = (checkbox) => {
//       const updatedCheckboxes = { ...checkboxes, [checkbox]: !checkboxes[checkbox] };
//       setCheckboxes(updatedCheckboxes);

//       if (checkbox === '1') {
//         setAColor(updatedCheckboxes[checkbox] ? colorTheme : 'black');
//         setBoxAOpacity(updatedCheckboxes[checkbox] ? '1' : '0.2')
//       }

//       if (checkbox === '2') {
//         setBColor(updatedCheckboxes[checkbox] ? colorTheme : 'black');
//         setBoxBOpacity(updatedCheckboxes[checkbox] ? '1' : '0.2')
//       }

//       if (checkbox === '3') {
//         setCColor(updatedCheckboxes[checkbox] ? colorTheme : 'black');
//         setBoxCOpacity(updatedCheckboxes[checkbox] ? '1' : '0.2')
//       }

//       if (checkbox === '4') {
//         setDColor(updatedCheckboxes[checkbox] ? colorTheme : 'black');
//         setBoxDOpacity(updatedCheckboxes[checkbox] ? '1' : '0.2')
//       }

//       if (checkbox === '5') {
//         setEColor(updatedCheckboxes[checkbox] ? colorTheme : 'black');
//         setBoxEOpacity(updatedCheckboxes[checkbox] ? '1' : '0.2')

//       }

//       if (checkbox === '6') {
//         setFColor(updatedCheckboxes[checkbox] ? colorTheme : 'black');
//         setBoxFOpacity(updatedCheckboxes[checkbox] ? '1' : '0.2')

//       }
//     };
  
//     const startSession = () => {
//       setAColor('black');
//       setBColor('black');
//       setCColor('black');
//       setDColor('black');
//       setEColor('black');
//       setBoxAOpacity('0.2');
//       setBoxBOpacity('0.2');
//       setBoxCOpacity('0.2');
//       setBoxDOpacity('0.2');
//       setBoxEOpacity('0.2');
//       const selectedBrackets = Object.entries(checkboxes)
//         .filter(([_, value]) => value)
//         .map(([key]) => Number(key));
//         console.log(selectedBrackets)
        
//       if (selectedBrackets.length > 0) {
//         setModalVisible(false);
//         fetchFlashcardsByBrackets(selectedBrackets); // Fetch flashcards for the session based on selected brackets
//       } else {
//         // Alert or handle if no checkbox is selected
//       }};
    
//       const selectedBrackets = Object.entries(checkboxes)
//         .filter(([_, value]) => value)
//         .map(([key]) => Number(key));

//         const setBracketsToOne = async () => {
//           const userRef = doc(firestore, 'users', uid);
//           try {
//             const userDoc = await getDoc(userRef);
//             if (userDoc.exists()) {
//               const userData = userDoc.data().data;
        
//               // Iterate through each category and subcategory to find and reset flashcards
//               userData.forEach(category => {
//                 category.subcategories.forEach(subcategory => {
//                   const flashcardsHolder = subcategory[Object.keys(subcategory)[0]].flashcardsHolder || [];
//                   flashcardsHolder.forEach(flashcard => {
//                     if (flashcard.bracket === 6) {
//                       flashcard.bracket = 1; // Reset bracket to 1
//                     }
//                   });
//                 });
//               });
        
//               // Update the Firestore document
//               await updateDoc(userRef, {
//                 data: userData
//               });
//               setNumberCurrent(0);
//               setNumberTotal(0);
              
//               setCheckboxes(checkboxesAfter)
//               setFlashcardFront('');
//               setFlashcardBack('');
//               fetchData();
//               setModalVisible(true);
//               alert('All learned flashcards have been reset.');
//               // Optionally, you can re-fetch or update local state here if necessary
//             }
//           } catch (error) {
//             console.error('Error updating flashcards:', error);
//           }
//         };
//   return (
//     <SafeAreaView style={[styles.container, { marginTop: statusBarHeight }]}>
//       <View style={styles.loginContainer2}>
//         <TouchableOpacity onPress={backHome} style={styles.backToMain}>
//           <Text style={{ textAlign: 'left', fontSize: 20, padding: 10, paddingTop: 5 }}>
//             <Image source={require('./assets/arrow_left.png')} style={styles.iconStyle3} />
//             Back to MainScreen
//           </Text>
//         </TouchableOpacity>
//         <Text style={{marginBottom: 20,marginTop:10, color: colorTheme, fontSize: 25, fontWeight: 500,}}>{showLastClicked}</Text>
        
//         <GestureFlipView width={deviceWidth * 0.90} height={deviceHeight * 0.35}>
//           {renderBack()}
//           {renderFront()}
//         </GestureFlipView>
//         <View style={{flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'space-around', }}>
        
//         <TouchableOpacity onPress={() => updateFlashcard(false, selectedBrackets)} style={{ marginTop: 20, marginRight: 40}}>
//           <Wrong width="70" height="70"/>
//         </TouchableOpacity>

//         <TouchableOpacity onPress={() => updateFlashcard(true, selectedBrackets)} style={{ marginTop: 20, marginLeft: 40 }}>
//           <Right width="70" height="70"/>
//         </TouchableOpacity>
        
//         </View>
//         <View style={{justifyContent: 'center', alignItems: 'center'   }}>
//           <Text style={{fontSize: 24, fontWeight: 400, marginTop: 15}}>Flashcard: {numberCurrent}/{numberTotal}</Text>
//           <View style={{justifyContent: 'center', alignItes: 'center', marginTop: 30 }}>
//                 <Text style={{fontSize: 16}}>
//                 Flashcard box : {currentBracket}
//                 </Text>
                
                
//           </View>
//           <View style={{justifyContent: 'center', alignItems: 'center' ,marginTop: 30  }}>
            
//                <TouchableOpacity style={{backgroundColor: '#c0c0c0', width: deviceWidth * 0.70, height: deviceHeight*0.05
//               , justifyContent: 'center', alignItems: 'center', borderRadius: 10, opacity: 1}}>

//                 <Text style={styles.clearButtonTextL} onPress={setBracketsToOne}>Reset Learned Flashcards</Text>

//                 </TouchableOpacity>
                
//           </View>
//         </View>
       
//       </View>
//       <View style={{ flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'space-around', marginBottom: 20, padding: 0, margin: 0}}>
//               <Box1 width="50" height="50" fill="none" stroke={boxOne} />
//               <Box2 width="50" height="50" fill="none" stroke={boxTwo} />
//               <Box3 width="50" height="50" fill="none" stroke={boxThree}/>
//               <Box4 width="50" height="50" fill="none" stroke={boxFour} />
//               <Box5 width="50" height="50" fill="none" stroke={boxFive} />
//               {/* {showRainbowCrown ? 
//         <RainbowCrown width="50" height="50" /> :  */}
//         <Crown width="50" height="50" fill="none" stroke={boxCrown} />
//       {/* } */}

//             </View>
//       <Modal
//   animationType="fade"
//   transparent={true}
//   visible={modalNo}
//   onRequestClose={() => setModalNo(false)}
// >
//   <TouchableWithoutFeedback>
//     <View style={styles.modalOverlay}>
//       <View style={styles.modalContent}>
//         {/* Close Button */}
//         <TouchableOpacity 
//           style={styles.closeButton} 
//           onPress={() => backHome()}
//         >
//           <Text style={styles.closeButtonText}>X</Text>
//         </TouchableOpacity>

//         <Text>There are no flashcards to learn with inside this subcategory... 
//           Come back after creating some flashcards!</Text>
//       </View>
//     </View>
//   </TouchableWithoutFeedback>
// </Modal>

//       <Modal
//         animationType="fade"
//         transparent={true}
//         visible={modalVisible}
//         onRequestClose={() => setModalVisible(false)}
//       >
//         <TouchableWithoutFeedback>
//           <View style={styles.modalOverlay}>
        
//     {/* Add more SVGs as needed */}
  
//             <View style={styles.modalContent}>
//             <View style={{position: 'absolute', top: 10, zIndex: 1, left: 10}}>
//     <BoxA width="100" height="100" stroke={AColor}  fill="none" opacity={boxAOpacity} />
//     </View>
//     <View style={{position: 'absolute', top: 30, zIndex: 1, right: 5}}>
//     <BoxB width="110" height="110" stroke={BColor}  fill="none"  opacity={boxBOpacity}/>
//     </View>
//     <View style={{position: 'absolute', top: 305, zIndex: 1, left: 25}}>
//     <BoxC width="100" height="100" stroke={CColor}  fill="none"  opacity={boxCOpacity}/>
//     </View>
//     <View style={{position: 'absolute', top: 180, zIndex: 1, right: 10}}>
//     <BoxD width="90" height="90" stroke={DColor}  fill="none"  opacity={boxDOpacity}/>
//     </View>
//     <View style={{position: 'absolute', top: 170, zIndex: 1, left: 10}}>
//     <BoxE width="80" height="80" stroke={EColor}  fill="none"  opacity={boxEOpacity}/>
//     </View>
//     <View style={{position: 'absolute', top: 310, zIndex: 1, right: 25}}>
//     <CrownA width="100" height="100" stroke={FColor}  fill="none"  opacity={boxFOpacity}/>
//     </View>
//               {
//                 Object.keys(checkboxes).map((checkbox) => (
//                   <TouchableOpacity
//                     key={checkbox}
//                     style={[
//                       styles.checkboxContainer,
//                       flashcardsCounts[checkbox] < 1 && { opacity: 0.35, zIndex: 2 },
//                     ]}
//                     onPress={() => handleCheckboxChange(checkbox)}
//                     disabled={flashcardsCounts[checkbox] < 1}
//                   >
//                     <Text>{checkbox}</Text>
//                     <View
//                       style={[
//                         styles.checkbox,
//                         { backgroundColor: checkboxes[checkbox] ? '#100c08' : 'white', zIndex: 2  },
//                       ]}
//                     /><View style={{position:'absolute',zIndex: 5, left: 15}}><Check width="35" height="35"/></View>
//                     <Text>({flashcardsCounts[checkbox]})</Text>
//                   </TouchableOpacity>
//                 ))
//               }
//               <TouchableOpacity
//                 style={[
//                   styles.startButton,
//                   {
//                     opacity: Object.values(checkboxes).some((value) => value) ? 1 : 0.5,
//                     marginTop: 10,
//                     marginBottom: 10,
//         padding: 10,
//         backgroundColor: '#100c08',
//         borderRadius: 5,
//         zIndex: 2,
//                   },
//                 ]}
//                 disabled={!Object.values(checkboxes).some((value) => value)}
//                 onPress={startSession}
//               >
//                 <Text style={styles.startButtonText}>Start Session</Text>
//               </TouchableOpacity>
//               <TouchableOpacity 
//           style={styles.closeButton} 
//           onPress={() => backHome()}
//         >
//           <Text style={styles.closeButtonText}>X</Text>
//         </TouchableOpacity>
//             </View>
            
//           </View>
//         </TouchableWithoutFeedback>
//       </Modal>
      
//     </SafeAreaView>
//   );
//               }

// export default Session;